--- a/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
+++ b/package/kernel/gpio-button-hotplug/src/gpio-button-hotplug.c
@@ -23,12 +23,11 @@
 #include <linux/netlink.h>
 #include <linux/kobject.h>
 #include <linux/input.h>
-#include <linux/interrupt.h>
 #include <linux/platform_device.h>
-#include <linux/of_gpio.h>
+#include <linux/gpio.h>
 #include <linux/gpio_keys.h>
 
-#define DRV_NAME	"gpio-keys"
+#define DRV_NAME	"gpio-keys-polled"
 
 #define BH_SKB_SIZE	2048
 
@@ -50,7 +49,6 @@
 
 struct bh_event {
 	const char		*name;
-	unsigned int		type;
 	char			*action;
 	unsigned long		seen;
 
@@ -70,7 +68,6 @@
 	int count;
 	int threshold;
 	int can_sleep;
-	struct gpio_keys_button *b;
 };
 
 extern u64 uevent_next_seqnum(void);
@@ -92,17 +89,16 @@
 	BH_MAP(BTN_7,		"BTN_7"),
 	BH_MAP(BTN_8,		"BTN_8"),
 	BH_MAP(BTN_9,		"BTN_9"),
-	BH_MAP(KEY_POWER,	"power"),
 	BH_MAP(KEY_RESTART,	"reset"),
-	BH_MAP(KEY_RFKILL,	"rfkill"),
+#ifdef KEY_WPS_BUTTON
 	BH_MAP(KEY_WPS_BUTTON,	"wps"),
-	BH_MAP(KEY_WIMAX,	"wwan"),
+#endif /* KEY_WPS_BUTTON */
 };
 
 /* -------------------------------------------------------------------------*/
 
-static __printf(3, 4)
-int bh_event_add_var(struct bh_event *event, int argv, const char *format, ...)
+static int bh_event_add_var(struct bh_event *event, int argv,
+		const char *format, ...)
 {
 	static char buf[128];
 	char *s;
@@ -117,7 +113,8 @@
 	va_end(args);
 
 	if (len >= sizeof(buf)) {
-		WARN(1, "buffer size too small");
+		BH_ERR("buffer size too small\n");
+		WARN_ON(1);
 		return -ENOMEM;
 	}
 
@@ -154,12 +151,6 @@
 	if (ret)
 		return ret;
 
-	if (event->type == EV_SW) {
-		ret = bh_event_add_var(event, 0, "TYPE=%s", "switch");
-		if (ret)
-			return ret;
-	}
-
 	ret = bh_event_add_var(event, 0, "SEEN=%ld", event->seen);
 	if (ret)
 		return ret;
@@ -198,8 +189,8 @@
 	kfree(event);
 }
 
-static int button_hotplug_create_event(const char *name, unsigned int type,
-		unsigned long seen, int pressed)
+static int button_hotplug_create_event(const char *name, unsigned long seen,
+		int pressed)
 {
 	struct bh_event *event;
 
@@ -211,7 +202,6 @@
 		return -ENOMEM;
 
 	event->name = name;
-	event->type = type;
 	event->seen = seen;
 	event->action = pressed ? "pressed" : "released";
 
@@ -233,30 +223,28 @@
 
 	return -1;
 }
-
 static void button_hotplug_event(struct gpio_keys_button_data *data,
-			   unsigned int type, int value)
+			   unsigned int type, unsigned int code, int value)
 {
 	struct bh_priv *priv = &data->bh;
 	unsigned long seen = jiffies;
 	int btn;
 
-	BH_DBG("event type=%u, code=%u, value=%d\n", type, data->b->code, value);
+	BH_DBG("event type=%u, code=%u, value=%d\n", type, code, value);
 
-	if ((type != EV_KEY) && (type != EV_SW))
+	if (type != EV_KEY)
 		return;
 
-	btn = button_get_index(data->b->code);
+	btn = button_get_index(code);
 	if (btn < 0)
 		return;
 
-	button_hotplug_create_event(button_map[btn].name, type,
+	button_hotplug_create_event(button_map[btn].name,
 			(seen - priv->seen) / HZ, value);
 	priv->seen = seen;
 }
 
-struct gpio_keys_button_dev {
-	int polled;
+struct gpio_keys_polled_dev {
 	struct delayed_work work;
 
 	struct device *dev;
@@ -264,224 +252,91 @@
 	struct gpio_keys_button_data data[0];
 };
 
-static int gpio_button_get_value(struct gpio_keys_button_data *bdata)
+static void gpio_keys_polled_check_state(struct gpio_keys_button *button,
+					 struct gpio_keys_button_data *bdata)
 {
-	int val;
+	int state;
 
 	if (bdata->can_sleep)
-		val = !!gpio_get_value_cansleep(bdata->b->gpio);
+		state = !!gpio_get_value_cansleep(button->gpio);
 	else
-		val = !!gpio_get_value(bdata->b->gpio);
-
-	return val ^ bdata->b->active_low;
-}
-
-static void gpio_keys_polled_check_state(struct gpio_keys_button_data *bdata)
-{
-	int state = gpio_button_get_value(bdata);
+		state = !!gpio_get_value(button->gpio);
 
+	state = !!(state ^ button->active_low);
 	if (state != bdata->last_state) {
-		unsigned int type = bdata->b->type ?: EV_KEY;
-
-		if (bdata->count < bdata->threshold) {
-			bdata->count++;
-			return;
-		}
-
-		if ((bdata->last_state != -1) || (type == EV_SW))
-			button_hotplug_event(bdata, type, state);
+		unsigned int type = button->type ?: EV_KEY;
 
+		button_hotplug_event(bdata, type, button->code, state);
+		bdata->count = 0;
 		bdata->last_state = state;
 	}
-
-	bdata->count = 0;
 }
 
-static void gpio_keys_polled_queue_work(struct gpio_keys_button_dev *bdev)
+static void gpio_keys_polled_queue_work(struct gpio_keys_polled_dev *bdev)
 {
 	struct gpio_keys_platform_data *pdata = bdev->pdata;
 	unsigned long delay = msecs_to_jiffies(pdata->poll_interval);
 
 	if (delay >= HZ)
-		delay = round_jiffies_relative(delay);
+	    delay = round_jiffies_relative(delay);
 	schedule_delayed_work(&bdev->work, delay);
 }
 
 static void gpio_keys_polled_poll(struct work_struct *work)
 {
-	struct gpio_keys_button_dev *bdev =
-		container_of(work, struct gpio_keys_button_dev, work.work);
+	struct gpio_keys_polled_dev *bdev =
+		container_of(work, struct gpio_keys_polled_dev, work.work);
+	struct gpio_keys_platform_data *pdata = bdev->pdata;
 	int i;
 
 	for (i = 0; i < bdev->pdata->nbuttons; i++) {
 		struct gpio_keys_button_data *bdata = &bdev->data[i];
-		gpio_keys_polled_check_state(bdata);
+
+		if (bdata->count < bdata->threshold)
+			bdata->count++;
+		else
+			gpio_keys_polled_check_state(&pdata->buttons[i], bdata);
 	}
 	gpio_keys_polled_queue_work(bdev);
 }
 
-static void gpio_keys_polled_close(struct gpio_keys_button_dev *bdev)
+static void __devinit gpio_keys_polled_open(struct gpio_keys_polled_dev *bdev)
 {
 	struct gpio_keys_platform_data *pdata = bdev->pdata;
+	int i;
 
-	cancel_delayed_work_sync(&bdev->work);
-
-	if (pdata->disable)
-		pdata->disable(bdev->dev);
-}
-
-static irqreturn_t button_handle_irq(int irq, void *_bdata)
-{
-	struct gpio_keys_button_data *bdata = (struct gpio_keys_button_data *) _bdata;
+	if (pdata->enable)
+		pdata->enable(bdev->dev);
 
-	button_hotplug_event(bdata, bdata->b->type ?: EV_KEY, gpio_button_get_value(bdata));
+	/* report initial state of the buttons */
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_keys_polled_check_state(&pdata->buttons[i], &bdev->data[i]);
 
-	return IRQ_HANDLED;
+	gpio_keys_polled_queue_work(bdev);
 }
 
-#ifdef CONFIG_OF
-static struct gpio_keys_platform_data *
-gpio_keys_get_devtree_pdata(struct device *dev)
+static void __devexit gpio_keys_polled_close(struct gpio_keys_polled_dev *bdev)
 {
-	struct device_node *node, *pp;
-	struct gpio_keys_platform_data *pdata;
-	struct gpio_keys_button *button;
-	int error;
-	int nbuttons;
-	int i = 0;
-
-	node = dev->of_node;
-	if (!node)
-		return NULL;
-
-	nbuttons = of_get_child_count(node);
-	if (nbuttons == 0)
-		return NULL;
-
-	pdata = devm_kzalloc(dev, sizeof(*pdata) + nbuttons * (sizeof *button),
-		GFP_KERNEL);
-	if (!pdata) {
-		error = -ENOMEM;
-		goto err_out;
-	}
-
-	pdata->buttons = (struct gpio_keys_button *)(pdata + 1);
-	pdata->nbuttons = nbuttons;
-
-	pdata->rep = !!of_get_property(node, "autorepeat", NULL);
-	of_property_read_u32(node, "poll-interval", &pdata->poll_interval);
-
-	for_each_child_of_node(node, pp) {
-		enum of_gpio_flags flags;
-
-		if (!of_find_property(pp, "gpios", NULL)) {
-			pdata->nbuttons--;
-			dev_warn(dev, "Found button without gpios\n");
-			continue;
-		}
-
-		button = &pdata->buttons[i++];
-
-		button->gpio = of_get_gpio_flags(pp, 0, &flags);
-		if (button->gpio < 0) {
-			error = button->gpio;
-			if (error != -ENOENT) {
-				if (error != -EPROBE_DEFER)
-					dev_err(dev,
-						"Failed to get gpio flags, error: %d\n",
-						error);
-				return ERR_PTR(error);
-			}
-		} else {
-			button->active_low = flags & OF_GPIO_ACTIVE_LOW;
-		}
-
-		if (of_property_read_u32(pp, "linux,code", &button->code)) {
-			dev_err(dev, "Button without keycode: 0x%x\n",
-				button->gpio);
-			error = -EINVAL;
-			goto err_out;
-		}
-
-		button->desc = of_get_property(pp, "label", NULL);
-
-		if (of_property_read_u32(pp, "linux,input-type", &button->type))
-			button->type = EV_KEY;
-
-		button->wakeup = !!of_get_property(pp, "gpio-key,wakeup", NULL);
-
-		if (of_property_read_u32(pp, "debounce-interval",
-					&button->debounce_interval))
-			button->debounce_interval = 5;
-	}
-
-	if (pdata->nbuttons == 0) {
-		error = -EINVAL;
-		goto err_out;
-	}
-
-	return pdata;
-
-err_out:
-	return ERR_PTR(error);
-}
-
-static struct of_device_id gpio_keys_of_match[] = {
-	{ .compatible = "gpio-keys", },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, gpio_keys_of_match);
-
-static struct of_device_id gpio_keys_polled_of_match[] = {
-	{ .compatible = "gpio-keys-polled", },
-	{ },
-};
-MODULE_DEVICE_TABLE(of, gpio_keys_polled_of_match);
+	struct gpio_keys_platform_data *pdata = bdev->pdata;
 
-#else
+	cancel_delayed_work_sync(&bdev->work);
 
-static inline struct gpio_keys_platform_data *
-gpio_keys_get_devtree_pdata(struct device *dev)
-{
-	return NULL;
+	if (pdata->disable)
+		pdata->disable(bdev->dev);
 }
-#endif
 
-static int gpio_keys_button_probe(struct platform_device *pdev,
-		struct gpio_keys_button_dev **_bdev, int polled)
+static int __devinit gpio_keys_polled_probe(struct platform_device *pdev)
 {
 	struct gpio_keys_platform_data *pdata = pdev->dev.platform_data;
 	struct device *dev = &pdev->dev;
-	struct gpio_keys_button_dev *bdev;
-	struct gpio_keys_button *buttons;
+	struct gpio_keys_polled_dev *bdev;
 	int error;
 	int i;
 
-	if (!pdata) {
-		pdata = gpio_keys_get_devtree_pdata(dev);
-		if (IS_ERR(pdata))
-			return PTR_ERR(pdata);
-		if (!pdata) {
-			dev_err(dev, "missing platform data\n");
-			return -EINVAL;
-		}
-		pdev->dev.platform_data = pdata;
-	}
-
-	if (polled && !pdata->poll_interval) {
-		dev_err(dev, "missing poll_interval value\n");
+	if (!pdata || !pdata->poll_interval)
 		return -EINVAL;
-	}
-
-	buttons = devm_kzalloc(dev, pdata->nbuttons * sizeof(struct gpio_keys_button),
-		       GFP_KERNEL);
-	if (!buttons) {
-		dev_err(dev, "no memory for button data\n");
-		return -ENOMEM;
-	}
-	memcpy(buttons, pdata->buttons, pdata->nbuttons * sizeof(struct gpio_keys_button));
 
-	bdev = devm_kzalloc(dev, sizeof(struct gpio_keys_button_dev) +
+	bdev = kzalloc(sizeof(struct gpio_keys_polled_dev) +
 		       pdata->nbuttons * sizeof(struct gpio_keys_button_data),
 		       GFP_KERNEL);
 	if (!bdev) {
@@ -489,24 +344,23 @@
 		return -ENOMEM;
 	}
 
-	bdev->polled = polled;
-
 	for (i = 0; i < pdata->nbuttons; i++) {
-		struct gpio_keys_button *button = &buttons[i];
+		struct gpio_keys_button *button = &pdata->buttons[i];
 		struct gpio_keys_button_data *bdata = &bdev->data[i];
 		unsigned int gpio = button->gpio;
 
 		if (button->wakeup) {
-			dev_err(dev, DRV_NAME "does not support wakeup\n");
-			return -EINVAL;
+			dev_err(dev, DRV_NAME " does not support wakeup\n");
+			error = -EINVAL;
+			goto err_free_gpio;
 		}
 
-		error = devm_gpio_request(dev, gpio,
+		error = gpio_request(gpio,
 				     button->desc ? button->desc : DRV_NAME);
 		if (error) {
 			dev_err(dev, "unable to claim gpio %u, err=%d\n",
 				gpio, error);
-			return error;
+			goto err_free_gpio;
 		}
 
 		error = gpio_direction_input(gpio);
@@ -514,151 +368,73 @@
 			dev_err(dev,
 				"unable to set direction on gpio %u, err=%d\n",
 				gpio, error);
-			return error;
+			goto err_free_gpio;
 		}
 
 		bdata->can_sleep = gpio_cansleep(gpio);
-		bdata->last_state = -1;
-
-		if (bdev->polled)
-			bdata->threshold = DIV_ROUND_UP(button->debounce_interval,
+		bdata->last_state = 0;
+		bdata->threshold = DIV_ROUND_UP(button->debounce_interval,
 						pdata->poll_interval);
-		else
-			bdata->threshold = 1;
-
-		bdata->b = &pdata->buttons[i];
 	}
 
 	bdev->dev = &pdev->dev;
 	bdev->pdata = pdata;
 	platform_set_drvdata(pdev, bdev);
 
-	*_bdev = bdev;
-
-	return 0;
-}
-
-static int gpio_keys_probe(struct platform_device *pdev)
-{
-	struct gpio_keys_platform_data *pdata;
-	struct gpio_keys_button_dev *bdev;
-	int ret, i;
-
-
-	ret = gpio_keys_button_probe(pdev, &bdev, 0);
-
-	if (ret)
-		return ret;
+	INIT_DELAYED_WORK(&bdev->work, gpio_keys_polled_poll);
 
-	pdata = pdev->dev.platform_data;
-	for (i = 0; i < pdata->nbuttons; i++) {
-		struct gpio_keys_button *button = &pdata->buttons[i];
-		struct gpio_keys_button_data *bdata = &bdev->data[i];
+	gpio_keys_polled_open(bdev);
 
-		if (!button->irq)
-			button->irq = gpio_to_irq(button->gpio);
-		if (button->irq < 0) {
-			dev_err(&pdev->dev, "failed to get irq for gpio:%d\n", button->gpio);
-			continue;
-		}
+	return 0;
 
-		ret = devm_request_threaded_irq(&pdev->dev, button->irq, NULL, button_handle_irq,
-						IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
-						dev_name(&pdev->dev), bdata);
-		if (ret < 0)
-			dev_err(&pdev->dev, "failed to request irq:%d for gpio:%d\n", button->irq, button->gpio);
-		else
-			dev_dbg(&pdev->dev, "gpio:%d has irq:%d\n", button->gpio, button->irq);
+err_free_gpio:
+	while (--i >= 0)
+		gpio_free(pdata->buttons[i].gpio);
 
-		if (bdata->b->type == EV_SW)
-			button_hotplug_event(bdata, EV_SW, gpio_button_get_value(bdata));
-	}
+	kfree(bdev);
+	platform_set_drvdata(pdev, NULL);
 
-	return 0;
+	return error;
 }
 
-static int gpio_keys_polled_probe(struct platform_device *pdev)
+static int __devexit gpio_keys_polled_remove(struct platform_device *pdev)
 {
-	struct gpio_keys_platform_data *pdata;
-	struct gpio_keys_button_dev *bdev;
-	int ret;
-	int i;
-
-	ret = gpio_keys_button_probe(pdev, &bdev, 1);
-
-	if (ret)
-		return ret;
-
-	INIT_DELAYED_WORK(&bdev->work, gpio_keys_polled_poll);
-
-	pdata = bdev->pdata;
-
-	if (pdata->enable)
-		pdata->enable(bdev->dev);
-
-	for (i = 0; i < pdata->nbuttons; i++)
-		gpio_keys_polled_check_state(&bdev->data[i]);
+	struct gpio_keys_polled_dev *bdev = platform_get_drvdata(pdev);
+	struct gpio_keys_platform_data *pdata = bdev->pdata;
+	int i = pdata->nbuttons;
 
-	gpio_keys_polled_queue_work(bdev);
+	gpio_keys_polled_close(bdev);
 
-	return ret;
-}
-
-static int gpio_keys_remove(struct platform_device *pdev)
-{
-	struct gpio_keys_button_dev *bdev = platform_get_drvdata(pdev);
+	while (--i >= 0)
+		gpio_free(pdata->buttons[i].gpio);
 
+	kfree(bdev);
 	platform_set_drvdata(pdev, NULL);
 
-	if (bdev->polled)
-		gpio_keys_polled_close(bdev);
-
 	return 0;
 }
 
-static struct platform_driver gpio_keys_driver = {
-	.probe	= gpio_keys_probe,
-	.remove	= gpio_keys_remove,
-	.driver	= {
-		.name	= "gpio-keys",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(gpio_keys_of_match),
-	},
-};
-
 static struct platform_driver gpio_keys_polled_driver = {
 	.probe	= gpio_keys_polled_probe,
-	.remove	= gpio_keys_remove,
+	.remove	= __devexit_p(gpio_keys_polled_remove),
 	.driver	= {
-		.name	= "gpio-keys-polled",
+		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(gpio_keys_polled_of_match),
 	},
 };
 
-static int __init gpio_button_init(void)
+static int __init gpio_keys_polled_init(void)
 {
-	int ret;
-
-	ret = platform_driver_register(&gpio_keys_driver);
-	if (ret)
-		return ret;
-
-	ret = platform_driver_register(&gpio_keys_polled_driver);
-	if (ret)
-		platform_driver_unregister(&gpio_keys_driver);
-
-	return ret;
+	return platform_driver_register(&gpio_keys_polled_driver);
 }
 
-static void __exit gpio_button_exit(void)
+static void __exit gpio_keys_polled_exit(void)
 {
-	platform_driver_unregister(&gpio_keys_driver);
 	platform_driver_unregister(&gpio_keys_polled_driver);
 }
 
-module_init(gpio_button_init);
-module_exit(gpio_button_exit);
+module_init(gpio_keys_polled_init);
+module_exit(gpio_keys_polled_exit);
 
 MODULE_AUTHOR("Gabor Juhos <juhosg@openwrt.org>");
 MODULE_AUTHOR("Felix Fietkau <nbd@openwrt.org>");
